#!/usr/bin/perl -w
# This program is open source, licensed under the simplified BSD license. For
# license terms, see the LICENSE file.

use strict;

use Getopt::Long;
use Data::Dumper;
use Pod::Usage;

#Digest md5
use Digest::MD5 qw(md5_base64);

=head1 logsaw.pl

logsaw.pl - retrieve and filter your logs

Version 1.0

=head1 SYNOPSIS

  logsaw.pl [-d|--debug] [-?|--help] [-H|--show-filename] [-n|--line-number] [--conf path_to_config_file]

=head1 DESCRIPTION

This program reads a bunch of log files generated by a program and sends the
interesting messages to stdout. It supports log files rotated and optionnaly
compressed by logrotate or another similar mecanism.

=head1 OPTIONS

=over 2

=item -d, --debug: output some debug informations.

=item -?, --help: show this help page.

=item -H, --show-filename: show log filenames in the output. Overwrites configuration entry SHOWFILENAME.

=item -n, --line-number: show line number of the entrey in the logfile. Overwrites configuration entry SHOWLINENR.

=item -f, --conf: configuration file. By default LOGSAWRC environment variable, "$HOME/.logsaw" as fallback.

=back

=head1 CONFIGURATION

The configuration file can these entries :

=over 2

=item * LOGFILES is a regular expression matching every filename we want to
scrutinize. They have to be in the same directory for instance :
postgresql-8.4-main-[0-9]{4}-[0-9]{2}.log". By default, match all files.

=item * LOGDIR is the directory where the LOGFILES are located, eg.
"/var/log/postgres". By default './'.

=item * REGEX is a rule to match for a line to be kept in the result. The rules
are perl regular expressions. The configuration file can have as many REGEX
than rules needed. By default, match all line.

=item * PAGER give an arbitrary command to open and read log files if IO::Zlib
is not available. For instance "zcat -f" or "gzip -dfc".

=item * SHOWFILENAME if not 0, enable C<--show-filename>. By default 0, is overwrited by C<--show-filename>.

=item * SHOWLINENR if not 0, enable C<--line-number>. By default 0, is overwrited by C<--line-number>.

=back

The next parameters set where to start processing log files on the next call of
logsaw and are updated by itself. If not set, logsaw will parse all matching
log files from the begining.

=over 2

=item * FILEID is the cheksum of the last seen file

=item * OFFSET is the position in this file

=back

=head1 SAMPLE

The following configuration file will:

=over 2

=item * match any line containing the FATAL, ERROR or WARNING strings

=item * against all files in the directory "/var/log/postgres"

=item * matching "postgresql\.log" (eg. postgresql.log, postgresql.log.1, 
postgresql.log.2.gz, ...)

=item * using "zcat -f" to open files

  LOGDIR=/var/log/postgres
  LOGFILES=postgresql\.log
  PAGER=zcat -f
  REGEX=FATAL
  REGEX=ERROR
  REGEX=WARNING

Note that on a system with IO::Zlib installed, PAGER is not required.

=back

=head1 AUTHORS

  Dalibo's team. http://www.dalibo.org

=head1 LICENSING

This program is open source, licensed under the simplified BSD license. For
license terms, see the LICENSE provided with the sources.

=cut

# global vars
my $conffile;
my $help;
my %conf = (    # conf hash
    'LOGFILES' => '',
    'LOGDIR'   => './',
    'REGEX'    => [],
    'SHOWFILENAME' => 0,
    'SHOWLINENR' => 0
);
my $debug        = 0;
my $showfilename = undef;
my $showlinenr   = undef;

sub usage {
    print "$_[0]\n" if $_[0];
    pod2usage( -exitval => 1 );
}

sub longusage {
    pod2usage( -verbose => 2, -exitval => 1 );
}

# This function open the given file using the parameter PAGER or fallback on
# IO::Zlib. The availability of IO::Zlib is checked right after the
# configuration file is loaded
sub open_logfile {
    my ($filepath) = @_;
    my $fd;

    if ( defined $conf{'PAGER'} ) {
        open( $fd, "$conf{'PAGER'} $filepath |" )
            or die("can not open file $filepath: «$!»\n");
        return $fd;
    }

    return IO::Zlib->new( $filepath, 'rb' );
}

# This function close the given file descriptor depending on the PAGER
# parameter or fallback on the IO::Zlib method. The availability of IO::Zlib is
# checked right after the configuration file is loaded
sub close_logfile {
    my ($filedesc) = @_;

    if ( defined $conf{'PAGER'} ) {
        return close($filedesc);
    }

    return $filedesc->close();
}

# This function determines the list of files to be scrutinized
# We retrieve them and their mtime, and return the list sorted by desc mtime
sub list_dir {
    die "$conf{LOGDIR} isn't a directory\n" unless -d $conf{LOGDIR};
    my @filelist;
    opendir( my $dh, $conf{LOGDIR} )
        or die "Cannot opendir $conf{LOGDIR} : $!\n";
    while ( my $entry = readdir($dh) ) {
        next if ( $entry eq '.' or $entry eq '..' );

        # Skip the files not matching the regexp
        next unless ( $entry =~ /${conf{LOGFILES}}/ );

        my $filename = $conf{LOGDIR} . '/' . $entry;

        #Skip the not files or empty files
        next unless ( -f $filename );
        next if ( -z $filename );

        my ($dev,   $ino,     $mode, $nlink, $uid,
            $gid,   $rdev,    $size, $atime, $mtime,
            $ctime, $blksize, $blocks
        ) = stat($filename);
        my @result = ( $filename, $mtime );
        push @filelist, \@result;
    }
    closedir($dh);

    # Now we've got an array containing file and mtime. We sort it descending,
    # then return it to the caller 
    my @sorted_filelist = sort { $b->[1] <=> $a->[1] } @filelist;

    return \@sorted_filelist;
}

# This function receives the (descending) ordered list of files and creates
# the list of files to read : All files more recent than the one matching the
# FILEID should be read.
sub build_file_list {
    my ( $reffilelist, $offset, $fileid ) = @_;
    my @filestoread;

    # offset and fileid can be undef (new configuration file)
    $offset or $offset = 0;
    $fileid or $fileid = '';

    foreach my $reffile ( @{$reffilelist} ) {
        my $filename = $reffile->[0];

        #Are you the one ?
        my $fh = open_logfile( $filename, 'rb' );

        my @fileinfo = ($filename);
        my $line     = <$fh>;
        if ($line)    # The file contains at least one line
        {

            # We need to check if this is the file
            my $cksum = md5_base64($line);
            if ( $fileid eq $cksum ) {

                # We store the offset for the file
                push @fileinfo, $offset;

         # This is the fileid. We put it at the beginning of the list (this is
         # the oldest file examined yet)
                unshift @filestoread, \@fileinfo;

                # and we have finished searching
                close_logfile($fh);
		# We have finished processing : we know all the filestoread
                last; 
            }
        }

	# It's not the file. We push it with an offset of zero (we'll read it
	# entirely)
        push @fileinfo, 0;
        unshift @filestoread, \@fileinfo;

        close_logfile($fh);
    }
    return \@filestoread;
}

# This function reads all files one by one, from the given offset to the end
# It writes to stdout the lines matching regexps from the file given as
# parameter
sub read_files {
    my ($reffilelist) = @_;

    my @regexes;

    # We want to cmopile the regular expressions only once
    foreach my $str ( @{ $conf{'REGEX'} } ) {
        chomp($str);
        push @regexes, (qr/$str/);
    }

    my $cksumlastnonemptyfile;
    my $lastlinenr;

    # Lets read the files
    foreach my $reffile ( @{$reffilelist} ) {
        my ( $filename, $offset ) = @{$reffile};

        my $fh = open_logfile( $filename, 'rb' );
        my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime(time);
        my $exectime = sprintf(
            "%02d/%02d/%d %02d:%02d:%02d",
            $mday, $mon + 1, $year + 1900,
            $hour, $min, $sec
        );

        # We go to the offset
        my $linenr = 0;
        my $line;
        print STDERR "processing $filename ($exectime)...\n" if $debug;
        if ($showfilename) {
            $filename = "$filename:";
        }
        else {
            $filename = '';
        }

        while ( $line = <$fh> ) {
            $linenr++;

            # This file is not empty, so we remember its md5 in case it's the
            # last we ever see
            $cksumlastnonemptyfile = md5_base64($line) if ( $linenr == 1 );
            next if ( $linenr <= $offset );    # We're not there yet
                                               # Does the line match ?
            foreach my $regex (@regexes) {
                if ( $line =~ $regex ) {
                    if ($showlinenr) {
                        print "$filename$linenr:$line";
                    }
                    else {
                        print "$filename$line";
                    }

                    last;    # No need to check other regexps
                }
            }
        }

        # We remember the lastlinenr in case this is the last file
        $lastlinenr = $linenr;
        print STDERR "done.\n" if $debug;
    }

    # This is it. We just have to close output file and
    # return the data about last file seen
    return ( [ $lastlinenr, $cksumlastnonemptyfile ] );
}

# Get options from command line
GetOptions(
    "conffile=s"      => \$conffile,
    "debug|d"         => \$debug,
    "help|?"          => \$help,
    "show-filename|H" => \$showfilename,
    "line-number|n"   => \$showlinenr
) or usage();

longusage() if ($help);

$conffile = $ENV{LOGSAWRC}          if defined $ENV{LOGSAWRC};
$conffile = "$ENV{HOME}/.logsaw"    unless $conffile;

usage(
    "Couldn't find configuration file (looked for: $conffile)!\n"
    ."Use --conf option \n\tor create ~/.logsaw\n".
    "\tor set LOGSAWRC environment variable with the corect path."
)
    unless ($conffile and -f $conffile);

# read configuration file
open CONF, $conffile or die "Can't open $conffile : $!\n";
while (<CONF>) {
    chomp;
    my ( $key, $value ) = split /=/;
    if ( $key eq 'REGEX' ) {
        push @{ $conf{'REGEX'} }, $value;
    }
    else {
        $conf{$key} = $value;
    }
}
close CONF;

# set show-filename and line-number from conf file if not defined
$showfilename = $conf{'SHOWFILENAME'} unless defined $showfilename;
$showlinenr   = $conf{'SHOWLINENR'}   unless defined $showlinenr;

# default to "match all" if no given regex
push @{ $conf{'REGEX'} }, '' if @{ $conf{'REGEX'} } == 0;

if ( not defined $conf{'PAGER'} ) {
    eval { require IO::Zlib };
    if ($@) {
        die <<EOT
Parameter PAGER is not set in your configuration file and I can not load module IO::Zlib
Please, set the parameter PAGER in your configuration file or make sure module IO::Zlib is installed on your system and available in your \@INC.
EOT
    }
}

# process log files
my $reffile_list = list_dir();
my $reffilestoread
    = build_file_list( $reffile_list, $conf{OFFSET}, $conf{FILEID} );
my $reflastfileread = read_files($reffilestoread);

if ($debug) {
    print "Conf: " . Dumper( \%conf );
    print "File list: " . Dumper($reffile_list);
    print "File to process: " . Dumper($reffilestoread);
    print "Last file processed: " . Dumper($reflastfileread);
}

# Write conf file
$conf{'FILEID'} = $reflastfileread->[1];
$conf{'OFFSET'} = $reflastfileread->[0];

open CONF, ">$conffile" or die "Can't open $conffile : $!\n";
foreach my $key ( sort keys %conf ) {
    if ( $key eq 'REGEX' ) {
        print CONF "REGEX=$_\n" foreach ( @{ $conf{REGEX} } );
    }
    else {
        print CONF "$key=$conf{$key}\n";
    }
}
close CONF;
