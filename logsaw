#!/usr/bin/perl -w
# This program is open source, licensed under the simplified BSD license. For
# license terms, see the LICENSE file.

use strict;

use vars qw($VERSION $PROGRAM);
use Getopt::Long;
use Data::Dumper;
use Pod::Usage;
use Fcntl qw(SEEK_CUR);
use Digest::MD5 qw(md5_base64);

$VERSION = '2.1';
$PROGRAM = 'logsaw';

=head1 logsaw

logsaw - retrieve and filter your logs

Version 2.0

=head1 SYNOPSIS

  logsaw [-d|--debug] [-?|--help] [-H|--show-filename] [-n|--line-number] [--conf path_to_config_file]

=head1 DESCRIPTION

This program reads a bunch of log files generated by a program and sends the
interesting messages to stdout. It supports log files rotated and optionnaly
compressed by logrotate or another similar mecanism.

=head1 OPTIONS

=over 2

=item -d, --debug: output some debug informations.

=item -?, --help: show this help page.

=item -H, --show-filename: show log filenames in the output. Overwrites configuration entry SHOWFILENAME.

=item -n, --line-number: show line number of the entrey in the logfile. Overwrites configuration entry SHOWLINENR.

=item -f, --conf: configuration file. By default LOGSAWRC environment variable, "$HOME/.logsaw" as fallback.

=item --version: Show the version of logsaw and exit.

=item --dry: Do not really run. It will not actually parse file and edit the configuration file.

=back

=head1 CONFIGURATION

The configuration file can have these entries :

=over 2

=item * LOGFILES is a regular expression matching every filename we want to
scrutinize. They have to be in the same directory for instance :
postgresql-8.4-main-[0-9]{4}-[0-9]{2}.log". By default, match all files.

=item * LOGDIR is the directory where the LOGFILES are located, eg.
"/var/log/postgres". By default './'.

=item * REGEX is a rule to match for a line to be kept in the result. The rules
are perl regular expressions. The configuration file can have as many REGEX
than rules needed. By default, match all lines.

=item * NOTREGEX is a rule to match for a line to be ignored in the result. The rules
are perl regular expressions. The configuration file can have as many REGEX
than rules needed. By default, match all lines. If you put REGEX and NOTREGEX at the
time in the configuration, both are applied: a line has to match a REGEX and not match
any NOTREGEX to be displayed.

=item * PAGER give an arbitrary command to open and read log files if IO::Zlib
is not available. For instance "zcat -f" or "gzip -dfc".

=item * SHOWFILENAME if not 0, enable C<--show-filename>. By default 0, is overwrited by C<--show-filename>.

=item * SHOWLINENR if not 0, enable C<--line-number>. By default 0, is overwrited by C<--line-number>.

=back

The next parameters set where to start processing log files on the next call of
logsaw and are updated by itself. If not set, logsaw will parse all matching
log files from the begining.

=over 2

=item * FILEID is the cheksum of the last seen file

=item * OFFSET is the position in this file

=item * LINE is the last line known in this file

=back

=head1 SAMPLE

The following configuration file will:

=over 2

=item * match any line containing the FATAL, ERROR or WARNING strings

=item * against all files in the directory "/var/log/postgres"

=item * matching "postgresql\.log" (eg. postgresql.log, postgresql.log.1, 
postgresql.log.2.gz, ...)

=item * using "zcat -f" to open files

  LOGDIR=/var/log/postgres
  LOGFILES=postgresql\.log
  PAGER=zcat -f
  REGEX=FATAL
  REGEX=ERROR
  REGEX=WARNING

Note that on a system with IO::Zlib installed, PAGER is not required.

=back

=head1 AUTHORS

  Dalibo's team. http://www.dalibo.org

=head1 LICENSING

This program is open source, licensed under the simplified BSD license. For
license terms, see the LICENSE provided with the sources.

=cut

# global vars
my $conffile;
my $help;
my $version;
my %conf = (    # conf hash
    'LOGFILES'     => '',
    'LOGDIR'       => './',
    'REGEX'        => [],
    'NOTREGEX'        => [],
    'SHOWFILENAME' => 0,
    'SHOWLINENR'   => 0
);
my $debug        = 0;
my $dry          = 0;
my $showfilename = undef;
my $showlinenr   = undef;
my %soft_seek; # track opened files with a PAGER

sub usage {
    print "$_[0]\n" if $_[0];
    pod2usage( -exitval => 1 );
}

sub longusage {
    pod2usage( -verbose => 2, -exitval => 1 );
}

sub version {
    print "$PROGRAM version $VERSION.\n";
    exit 0;
}

# This function open the given file using open(), optionnaly forking PAGER to
# read it.
# is loaded
sub open_logfile {
    my ($filepath) = @_;
    my $fh = undef;

    return undef unless -f $filepath;

    if ( -B $filepath and defined $conf{'PAGER'} ) {
        # Only use the pager if the file looks like a binary one. This avoid
        # to use the slow emulated seek()
        open( $fh, "$conf{'PAGER'} $filepath |" )
            or die("can not open file $filepath: «$!»\n");

        $soft_seek{fileno $fh} = 1;

        return $fh;
    }

    open $fh, '<', $filepath
        or die("can not open file $filepath: «$!»\n");;

    $soft_seek{fileno $fh} = 0;

    return $fh;
}

# This function seek to the given position in the given file descriptor.
# If the file descriptor is using PAGER, emulate seek.
sub seek_logfile {
    my ( $filedesc, $seek ) = @_;

    return if $dry;

    print STDERR "start seeking to $seek..." if $debug;

    # implement seek with a PAGER...
    if ( $soft_seek{fileno $filedesc} == 1 ) {
        my $buff   = 4096;
        while ( $seek >= $buff ) {
            read $filedesc, $_, $buff;
            $seek -= $buff;
        }

        read $filedesc, $_, $seek if $seek;
    }
    else {
        seek $filedesc, $seek, SEEK_CUR;
    }

    print STDERR "end.\n" if $debug;

    return;
}

# This function determines the list of files to be scrutinized
# We retrieve them and their mtime, and return the list sorted by desc mtime
sub list_dir {
    die "$conf{LOGDIR} isn't a directory\n" unless -d $conf{LOGDIR};
    my @filelist;

    opendir( my $dh, $conf{LOGDIR} )
        or die "Cannot opendir $conf{LOGDIR} : $!\n";

    while ( my $entry = readdir($dh) ) {
        next if ( $entry eq '.' or $entry eq '..' );

        # Skip the files not matching the regexp
        next unless ( $entry =~ /${conf{LOGFILES}}/ );

        my $filename = $conf{LOGDIR} . '/' . $entry;

        #Skip the not files or empty files
        next unless ( -f $filename );
        next if ( -z $filename );

        my ($dev,   $ino,     $mode, $nlink, $uid,
            $gid,   $rdev,    $size, $atime, $mtime,
            $ctime, $blksize, $blocks
        ) = stat($filename);
        my @result = ( $filename, $mtime );
        push @filelist, \@result;
    }

    closedir($dh);

    # Now we've got an array containing file and mtime. We sort it descending,
    # then return it to the caller
    my @sorted_filelist = sort { $b->[1] <=> $a->[1] } @filelist;

    return \@sorted_filelist;
}

# This function receives the (descending) ordered list of files and creates
# the list of files to read : All files more recent than the one matching the
# FILEID should be read.
sub build_file_list {
    my ($reffilelist) = @_;
    my $offset        = $conf{OFFSET} || 0;
    my $fileid        = $conf{FILEID} || '';
    my @filestoread;

    foreach my $reffile ( @{$reffilelist} ) {
        my $filename = $reffile->[0];

        # Are you the one ?
        my $fh = open_logfile($filename);

        next unless defined $fh;

        my @fileinfo = ($filename);
        my $line     = <$fh>;
        if ($line)    # The file contains at least one line
        {

            # We need to check if this is the file
            my $cksum = md5_base64($line);
            print STDERR "FILEID of $filename: $cksum\n" if $debug;

            if ( $fileid eq $cksum ) {
                print STDERR "This is the last file processed.\n" if $debug;

                # We store the offset for the file and if it is a binary file
                push @fileinfo, $offset, -B $filename;

                # This is the fileid. We put it at the beginning of the list
                # (this is the oldest file examined yet)
                unshift @filestoread, \@fileinfo;

                # and we have finished searching
                close $fh;

                # We have finished processing : we know all the filestoread
                last;
            }
        }

        # It's not the file. We push it with an offset of zero (we'll read it
        # entirely), and if it is a binary one.
        push @fileinfo, 0, -B $filename;
        unshift @filestoread, \@fileinfo;

        close $fh;
    }
    return \@filestoread;
}

# This function reads all files one by one, from the given offset to the end
# It writes to stdout the lines matching regexps and not maching notregexps from the file given as
# parameter
sub read_files {
    my ($reffilelist) = @_;
    my @regexes;
    my @notregexes;
    my $cksumlastnonemptyfile;
    my $lastfilesizereaded;
    my $lastfilelinenr;

    # We want to cmopile the regular expressions only once
    foreach my $str ( @{ $conf{'REGEX'} } ) {
        chomp($str);
        push @regexes, (qr/$str/);
    }
    foreach my $str ( @{ $conf{'NOTREGEX'} } ) {
        chomp($str);
        push @notregexes, (qr/$str/);
    }

    # Read all files
    FILES: foreach my $reffile ( @{$reffilelist} ) {
        my ( $filename, $offset ) = @{$reffile};
        my $line;
        my $linenr = 0;
        my $fh     = open_logfile($filename);
        my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime(time);
        my $exectime = sprintf(
            "%02d/%02d/%d %02d:%02d:%02d",
            $mday, $mon + 1, $year + 1900,
            $hour, $min, $sec
        );

        next unless defined $fh;

        print STDERR "processing $filename ($exectime)...\n" if $debug;

        if ($showfilename) {
            $filename = "$filename:";
        }
        else {
            $filename = '';
        }

        $line = <$fh>;

        next FILES unless $line;

        $offset -= length $line;

        #  This file is not empty, so we remember its md5 in case it's the
        # last we ever see
        $cksumlastnonemptyfile = md5_base64($line);

        # seek to the appropriate offset
        if ( $offset > 0 ) {
            seek_logfile( $fh, $offset );
            $linenr = $conf{'LINE'};
            $line   = <$fh>;
        }

        while (not $dry and $line) {
            $linenr++;

            # Does the line match ?
            # @regexes cannot be empty (if nothing is specified, a single empty regex is built),
            # @notregexes can be, so we may not enter its loop at all
            REGEXP: foreach my $regex (@regexes) {
                if ( $line =~ $regex ) {
                    # Check that it doesn't also match a notregex
                    foreach my $notregex (@notregexes)
                    {
                        if ($line =~ $notregex)
                        {
                            last REGEXP; # Ignore the line
                        }
                    }
                    if ($showlinenr) {
                        print "$filename$linenr:$line";
                    }
                    else {
                        print "$filename$line";
                    }

                    last REGEXP;    # No need to check other regexps
                }
            }
        }
        continue {
            $line = <$fh>;
        }

        # We remember the number of bytes readed in case this is the last file
        $lastfilesizereaded = tell $fh;
        $lastfilelinenr     = $linenr;

        print STDERR "done.\n" if $debug;

        close $fh;
    }

    # This is it. We just have to close output file and
    # return the data about last file seen
    return (
        [ $lastfilesizereaded, $cksumlastnonemptyfile, $lastfilelinenr ] );
}

# Get options from command line
GetOptions(
    "conffile=s"      => \$conffile,
    "debug|d"         => \$debug,
    "help|?"          => \$help,
    "show-filename|H" => \$showfilename,
    "line-number|n"   => \$showlinenr,
    "version"         => \$version,
    "dry"             => \$dry
) or usage();

longusage() if ($help);

version() if $version;

$conffile = $ENV{LOGSAWRC} if defined $ENV{LOGSAWRC};
$conffile = "$ENV{HOME}/.logsaw" unless $conffile;

usage(    "Couldn't find configuration file (looked for: $conffile)!\n"
        . "Use --conf option \n\tor create ~/.logsaw\n"
        . "\tor set LOGSAWRC environment variable with the corect path." )
    unless ( $conffile and -f $conffile );

# read configuration file
open CONF, $conffile or die "Can't open $conffile : $!\n";
while (<CONF>) {
    next if /^\s*#/;
    chomp;
    my ( $key, $value ) = split /=/;
    if ( $key eq 'REGEX' ) {
        push @{ $conf{'REGEX'} }, $value;
    }
    elsif ($key eq 'NOTREGEX') {
        push @{ $conf{'NOTREGEX'} }, $value;
    }
    else {
        $conf{$key} = $value;
    }
}
close CONF;

# set show-filename and line-number from conf file if not defined
$showfilename = $conf{'SHOWFILENAME'} unless defined $showfilename;
$showlinenr   = $conf{'SHOWLINENR'}   unless defined $showlinenr;

# default to "match all" if no given regex
push @{ $conf{'REGEX'} }, '' if @{ $conf{'REGEX'} } == 0;

# process log files
my $reffile_list   = list_dir();
my $reffilestoread = build_file_list($reffile_list);

if ($debug) {
    print STDERR "Conf: " . Dumper( \%conf );
    print STDERR "File list: " . Dumper($reffile_list);
    print STDERR "File to process: " . Dumper($reffilestoread);
}

# check if we need a pager
if ( not defined $conf{'PAGER'} and grep($_->[2], @{ $reffilestoread }) > 0 ) {
        die <<EOT
Parameter PAGER is not set in your configuration file and it seems some files to parse are binary ones.
Please, set the parameter PAGER in your configuration file.
EOT
}

my $reflastfileread = read_files($reffilestoread);

print STDERR "Last file processed: " . Dumper($reflastfileread) if $debug;

# Write conf file
$conf{'OFFSET'} = $reflastfileread->[0];
$conf{'FILEID'} = $reflastfileread->[1];
$conf{'LINE'}   = $reflastfileread->[2];

exit if $dry;

open CONF, ">$conffile" or die "Can't open $conffile : $!\n";
foreach my $key ( sort keys %conf ) {
    if ( $key eq 'REGEX' ) {
        print CONF "REGEX=$_\n" foreach ( @{ $conf{REGEX} } );
    }
    elsif ( $key eq 'NOTREGEX' ) {
        print CONF "NOTREGEX=$_\n" foreach ( @{ $conf{NOTREGEX} } );
    }
    else {
        print CONF "$key=$conf{$key}\n";
    }
}
close CONF;
