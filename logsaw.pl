#!/usr/bin/perl -w

use strict;

use Getopt::Long;
use Data::Dumper;
use Pod::Usage;
use Config::Tiny;

#use IO::File;
# Compression libs
use IO::Zlib; # able to open uncompressed file as well (compression 0)

#Digest md5
use Digest::MD5 qw(md5_base64);

=head1 logsaw.pl

logsaw.pl - retrieve and filter your logs

=head1 SYNOPSIS

  logsaw.pl [-d] --conf path_to_config_file [-h]
  
=head1 DESCRIPTION

This program reads a bunch of log files generated by a program (and rotated by logrotate or another similar mecanism) and sends the interesting messages into an output file.

=head1 Configuration file

The configuration file contains these mandatory entries :

=over 2

=item * LOGFILES is a regular expression matching every filename we want to scrutinize. They have to be in the same directory for instance : postgresql-8.4-main-[0-9]{4}-[0-9]{2}.log"

=item * LOGDIR is the directory where the LOGFILES are located, "/var/log/postgres"

=item * REGEXFILE is a filename containing the rules to match for a line to be kept in the result, for instance "/etc/logsaw_filter". The rules are perl regular expressions, one per line.

=item * OUTFILE is the output file, for instance "/var/log/postgresql/logsaw_result.log"

=back

The next parameters are updated everytime the program is run :

=over 2

=item * FILEID is the cheksum of the last seen file

=item * OFFSET is the position in this file 

=back

=head1 Author

  Dalibo's team. http://www.dalibo.org

=cut

#globals vars
my $conf; # Conf object
my %conf; # conf hash for conveniance
my $debug = 0;

sub usage
{
  pod2usage(-exitval => 1);
}

sub longusage
{
  pod2usage(-verbose => 2, -exitval => 1);
}

# This function determines the list of files to be scrutinized
# We retrieve them and their mtime, and return the list sorted by desc mtime
sub list_dir
{
  die "$conf{LOGDIR} isn't a directory\n" unless -d $conf{LOGDIR};
  my @filelist;
  opendir (my $dh,$conf{LOGDIR}) or die "Cannot opendir $conf{LOGDIR} : $!\n";
  while (my $entry=readdir($dh))
  {
    next if ($entry eq '.' or $entry eq '..');
    # Skip the files not matching the regexp
    next unless ($entry =~ /${conf{LOGFILES}}/);
    
    my $filename = $conf{LOGDIR}.'/'.$entry;
    
    #Skip the not files or empty files
    next unless (-f $filename);
    next if (-z $filename);
    
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	$atime,$mtime,$ctime,$blksize,$blocks)
	= stat($filename);
    my @result=($filename,$mtime);
    push @filelist,\@result;
  }
  closedir ($dh);
  
  # Now we've got an array containing file and mtime. We sort it descending, then return it to the caller
  my @sorted_filelist=sort{$b->[1] <=> $a->[1]}@filelist;
  return \@sorted_filelist;
}

# This function receives the (descending) ordered list of files and creates the list of files to read :
# All files more recent than the one matching the FILEID should be read.
sub build_file_list
{
  my ($reffilelist,$offset,$fileid)=@_;
  my @filestoread;
  
  # offset and fileid can be undef (new configuration file)
  $offset or $offset=0;
  $fileid or $fileid='';
  
  foreach my $reffile (@{$reffilelist})
  {
    my $filename=$reffile->[0];

    #Are you the one ?
    my $fh=IO::Zlib->new($filename, 'rb');

    my @fileinfo=($filename);
    my $line=<$fh>;
    if ($line) # The file contains at least one line
    {
      # We need to check if this is the file
      my $cksum=md5_base64($line);
      if ($fileid eq $cksum)
      {
		# We store the offset for the file
		push @fileinfo,$offset;
		# This is the fileid. We put it at the beginning of the list (this is
		# the oldest file examined yet)
		unshift @filestoread,\@fileinfo;
		# and we have finished searching
		$fh->close();
		last; # We have finished processing : we know all the filestoread
      }
    }

    # It's not the file. We push it with an offset of zero (we'll read it entirely)
    push @fileinfo,0;
    unshift @filestoread,\@fileinfo;

    $fh->close();
  }
  return \@filestoread;
}

# This function reads all files one by one, from the given offset to the end
# It ignores the lines matching regexps from the file given as parameter
sub read_files
{
  my ($regexpath,$reffilelist,$outfilename)=@_;
  # First, let's load the regexps

  open my $regexfile,$regexpath or die "Can't open $regexpath : $!\n";
  my @regexesfromfile=<$regexfile>;
  close $regexfile;
  
  my @regexes;
  # We want to cmopile the regular expressions only once
  while (my $str = pop(@regexesfromfile))
  {
    chomp($str);
    push @regexes,( qr/$str/);
  }
  
  # We open the output file
  open my $outfile,">>$outfilename" or die "Can't write into $outfilename : $!\n";
  
  my $cksumlastnonemptyfile;
  my $lastlinenr;
  # Lets read the files
  foreach my $reffile (@{$reffilelist})
  {
    my ($filename,$offset)=@{$reffile};

    my $fh=IO::Zlib->new($filename, 'rb');
    my ($sec,$min,$hour,$mday,$mon,$year) = localtime(time);
	my $exectime = sprintf("%02d/%02d/%d %02d:%02d:%02d", $mday, $mon+1, $year+1900, $hour, $min, $sec);

    # We go to the offset
    my $linenr=0;
    my $line;
    print STDERR "processing $filename...\n" if $debug;
    print $outfile "=====> $filename ($exectime) <=====\n" or die "Can't write to $outfilename : $!\n";
    while ($line=<$fh>)
    {
      $linenr++;
	  # This file is not empty, so we remember its md5 in case it's the last we ever see
	  $cksumlastnonemptyfile=md5_base64($line) if ($linenr==1);
      next if ($linenr <= $offset); # We're not there yet
      # Does the line match ?
	  foreach my $regex (@regexes)
	  {
		if ($line =~ $regex)
		{
		  print $outfile "$linenr: $line" or die "Can't write to $outfilename : $!\n";
		  if ($debug) {
			  chomp($line);
			  print STDERR "\t\"$line\" match !\n" 
		  }
		  last; # No need to check other regexps
		}
	  }
    }
    # We remember the lastlinenr in case this is the last file
    $lastlinenr=$linenr;
    print STDERR "done.\n" if $debug;
  }
  # This is it. We just have to close output file and
  # return the data about last file seen
  close $outfile;
  return([$lastlinenr,$cksumlastnonemptyfile]);
}

# This function creates a new configuration file and removes the old one
sub save_status
{
  my ($conffilename,$offset,$cksum)=@_;
  my $outconffilename=$conffilename . ".tmp";
  
  

  open my $outfh,">$outconffilename" or die "Can't write temporary config file $outconffilename : $!\n";
  foreach my $key ('LOGFILES','LOGDIR','REGEXFILE','OUTFILE')
  {
    print $outfh "$key=${conf{$key}}\n";
  }
  print $outfh "FILEID=$cksum\n";
  print $outfh "OFFSET=$offset\n";
  close $outfh;
  rename($outconffilename,$conffilename)
}

# The global configuration
my $conffile;
my $help;

# Get options from command line
GetOptions ("conffile=s"   => \$conffile, 
  "debug" => \$debug, 
  "help" => \$help
) or usage();

longusage() if ($help);
usage() unless ($conffile);

$conf = Config::Tiny->read($conffile);
%conf = %{$conf->{_}};

my $reffile_list=list_dir();
my $reffilestoread=build_file_list($reffile_list,$conf{OFFSET},$conf{FILEID});
my $reflastfileread=read_files($conf{REGEXFILE},$reffilestoread,$conf{OUTFILE});

if ($debug) {
	print "Conf: ". Dumper(\%conf);
	print "File list: ". Dumper($reffile_list);
	print "File to process: ". Dumper($reffilestoread);
	print "Last file processed: ". Dumper($reflastfileread);
}

# Write conf file
$conf->{_}->{'FILEID'} = $reflastfileread->[1];
$conf->{_}->{'OFFSET'} = $reflastfileread->[0];
$conf->write($conffile);
